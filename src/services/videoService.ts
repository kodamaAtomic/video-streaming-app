import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { VideoMetadata, RegisteredFolder } from '../types';
import ThumbnailGenerator from './thumbnailGenerator';

export default class VideoService {
  private videoDir: string;
  private readonly thumbnailGenerator: ThumbnailGenerator;
  private videos: Map<string, VideoMetadata> = new Map();
  private readonly registeredFoldersFile: string;

  constructor(videoDir?: string) {
    this.videoDir = videoDir || path.join(__dirname, '../storage/videos');
    this.thumbnailGenerator = new ThumbnailGenerator(path.join(__dirname, '../storage/thumbnails'));
    this.registeredFoldersFile = path.join(__dirname, '../storage/registeredFolders.json');
    console.log(`Video directory set to: ${this.videoDir}`);
    console.log(`Current __dirname: ${__dirname}`);
    this.initializeVideoDir();
    this.loadVideos();
  }

  private initializeVideoDir(): void {
    if (!fs.existsSync(this.videoDir)) {
      fs.mkdirSync(this.videoDir, { recursive: true });
      console.log(`Created video directory: ${this.videoDir}`);
    }
  }

  private generateVideoId(filename: string): string {
    return path.parse(filename).name;
  }

  private async loadVideos(): Promise<void> {
    try {
      const files = fs.readdirSync(this.videoDir);
      
      // ÈÄöÂ∏∏„ÅÆ„Éì„Éá„Ç™„Éï„Ç°„Ç§„É´„Å®TS„Éï„Ç°„Ç§„É´„ÇíÂàÜÂà•
      const videoFiles = files.filter(file => 
        ['.mp4', '.avi', '.mov', '.mkv', '.webm'].some(ext => 
          file.toLowerCase().endsWith(ext)
        )
      );
      
      const tsFiles = files.filter(file => 
        file.toLowerCase().endsWith('.ts')
      );

      console.log(`Found ${videoFiles.length} video files and ${tsFiles.length} TS files in ${this.videoDir}`);
      
      // „Éì„Éá„Ç™„É°„Çø„Éá„Éº„Çø„ÅÆÁîüÊàêÔºà‰∏¶ÂàóÂá¶ÁêÜ„Å™„ÅóÔºâ
      const videoMetadatas: VideoMetadata[] = [];
      
      for (const file of videoFiles) {
        try {
          const videoPath = path.join(this.videoDir, file);
          const stats = fs.statSync(videoPath);
          const videoId = path.parse(file).name;
          
          const metadata: VideoMetadata = {
            id: videoId,
            filename: file,
            originalName: file,
            path: videoPath,
            size: stats.size,
            mimetype: this.getMimeType(file),
            uploadDate: stats.mtime,
            createdAt: stats.mtime,
            updatedAt: stats.mtime,
            thumbnailPath: undefined
          };

          videoMetadatas.push(metadata);
          this.videos.set(videoId, metadata);
          console.log(`Loaded video metadata: ${file}`);
        } catch (error) {
          console.error(`Error loading video ${file}:`, error);
        }
      }

      // TS„Éï„Ç°„Ç§„É´„ÅÆ„É°„Çø„Éá„Éº„ÇøÁîüÊàê
      for (const tsFile of tsFiles) {
        try {
          // ÂêåÂêç„ÅÆMP4„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          const baseName = path.basename(tsFile, '.ts');
          const mp4Exists = videoFiles.some(videoFile => 
            path.basename(videoFile, path.extname(videoFile)) === baseName
          );

          if (!mp4Exists) {
            const tsPath = path.join(this.videoDir, tsFile);
            const stats = fs.statSync(tsPath);
            const videoId = this.generateVideoId(tsFile);

            const metadata: VideoMetadata = {
              id: videoId,
              filename: tsFile,
              originalName: tsFile,
              path: tsPath,
              size: stats.size,
              mimetype: 'video/mp2t',
              thumbnailPath: '', // TS„É≠„Ç¥„Çµ„É†„Éç„Ç§„É´„ÅØÂæå„ÅßË®≠ÂÆö
              uploadDate: stats.mtime,
              createdAt: stats.mtime,
              updatedAt: stats.mtime,
              timestamp: stats.mtime.toISOString(),
              playCount: 0,
              isFavorite: false,
              isTranscoding: false,
              isTs: true // TS„Éï„Ç°„Ç§„É´„Éï„É©„Ç∞
            };

            this.videos.set(videoId, metadata);
            console.log(`Loaded TS file metadata: ${tsFile}`);
          } else {
            console.log(`Skipping TS file ${tsFile} - MP4 version exists`);
          }
        } catch (error) {
          console.error(`Error loading TS file ${tsFile}:`, error);
        }
      }

      // „Çµ„É†„Éç„Ç§„É´ÁîüÊàê„Çí‰∏¶ÂàóÂÆüË°åÔºàTS„Éï„Ç°„Ç§„É´„ÅØÈô§Â§ñÔºâ
      if (videoMetadatas.length > 0) {
        const nonTsVideos = videoMetadatas.filter(video => !video.path.toLowerCase().endsWith('.ts'));
        console.log(`üöÄ Starting parallel thumbnail generation for ${nonTsVideos.length} videos (${videoMetadatas.length - nonTsVideos.length} TS files skipped)`);
        
        // TS„Éï„Ç°„Ç§„É´‰ª•Â§ñ„ÅÆ„Åø„Çí„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÂØæË±°„Å®„Åô„Çã
        const thumbnailJobs = nonTsVideos.map(video => ({
          videoPath: video.path,
          videoId: video.id
        }));

        const result = await this.thumbnailGenerator.generateThumbnailsConcurrent(thumbnailJobs, {
          skipExisting: true,
          optimizeSettings: true
        });

        // „Çµ„É†„Éç„Ç§„É´„Éë„Çπ„ÇíÊõ¥Êñ∞
        result.successful.forEach(thumbnailPath => {
          const filename = path.basename(thumbnailPath);
          const videoId = filename.replace('_thumbnail.png', '');
          const video = this.videos.get(videoId);
          if (video) {
            video.thumbnailPath = thumbnailPath;
            console.log(`‚úÖ Thumbnail linked: ${video.originalName}`);
          }
        });

        // „Ç®„É©„ÉºÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
        result.failed.forEach(({ videoId, error }) => {
          console.error(`‚ùå Thumbnail generation failed for ${videoId}: ${error}`);
        });

        console.log(`üèÅ Thumbnail generation completed: ${result.successful.length} successful, ${result.failed.length} failed`);
      }
    } catch (error) {
      console.error('Error loading videos:', error);
    }
  }

  private getMimeType(filename: string): string {
    const ext = path.extname(filename).toLowerCase();
    const mimeTypes: { [key: string]: string } = {
      '.mp4': 'video/mp4',
      '.avi': 'video/x-msvideo',
      '.mov': 'video/quicktime',
      '.mkv': 'video/x-matroska',
      '.webm': 'video/webm'
    };
    return mimeTypes[ext] || 'video/mp4';
  }

  async getAllVideos(): Promise<VideoMetadata[]> {
    return Array.from(this.videos.values());
  }

  async getVideoById(id: string): Promise<VideoMetadata | undefined> {
    return this.videos.get(id);
  }

  async ensureThumbnail(video: VideoMetadata): Promise<void> {
    try {
      // „Ç≠„É£„ÉÉ„Ç∑„É•Ê©üËÉΩ‰ªò„Åç„ÅÆ„Çµ„É†„Éç„Ç§„É´ÁîüÊàê„Çí‰ΩøÁî®
      const thumbnailPath = await this.thumbnailGenerator.generateThumbnailWithCache(
        video.path, 
        video.id
      );
      video.thumbnailPath = thumbnailPath;
      console.log(`Ensured thumbnail for ${video.originalName}: ${thumbnailPath}`);
    } catch (error) {
      console.error(`Failed to generate thumbnail for ${video.originalName}:`, error);
      video.thumbnailPath = undefined;
    }
  }

  async addVideo(file: Express.Multer.File | undefined): Promise<VideoMetadata> {
    if (!file) {
      throw new Error('No file provided');
    }

    console.log(`Adding video: ${file.originalname}`);
    console.log(`File path: ${file.path}`);
    
    const videoId = path.parse(file.filename).name;
    
    const metadata: VideoMetadata = {
      id: videoId,
      filename: file.filename,
      originalName: file.originalname,
      path: file.path,
      size: file.size,
      mimetype: file.mimetype,
      uploadDate: new Date(),
      createdAt: new Date(),
      updatedAt: new Date(),
      thumbnailPath: undefined
    };

    await this.ensureThumbnail(metadata);

    this.videos.set(videoId, metadata);
    console.log(`Video added successfully: ${metadata.originalName}`);
    return metadata;
  }

  async deleteVideo(id: string): Promise<boolean> {
    const video = this.videos.get(id);
    if (!video) {
      console.log(`Video not found in memory: ${id}`);
      return false;
    }

    console.log(`Attempting to delete video: ${video.originalName}`);
    console.log(`Video path: ${video.path}`);

    try {
      if (fs.existsSync(video.path)) {
        fs.unlinkSync(video.path);
        console.log(`Deleted video file: ${video.path}`);
      } else {
        console.log(`Video file not found: ${video.path}`);
      }

      if (video.thumbnailPath && fs.existsSync(video.thumbnailPath)) {
        fs.unlinkSync(video.thumbnailPath);
        console.log(`Deleted thumbnail: ${video.thumbnailPath}`);
      }

      this.videos.delete(id);
      console.log(`Video ${id} successfully removed from memory`);
      
      return true;
    } catch (error) {
      console.error(`Failed to delete video ${id}:`, error);
      return false;
    }
  }

  async debugVideoInfo(id: string): Promise<void> {
    const video = this.videos.get(id);
    if (video) {
      console.log('=== Video Debug Info ===');
      console.log('ID:', video.id);
      console.log('Filename:', video.filename);
      console.log('Original Name:', video.originalName);
      console.log('Path:', video.path);
      console.log('Path exists:', fs.existsSync(video.path));
      console.log('Thumbnail Path:', video.thumbnailPath);
      console.log('Thumbnail exists:', video.thumbnailPath ? fs.existsSync(video.thumbnailPath) : 'No thumbnail path');
      console.log('========================');
    }
  }

  async changeVideoDirectory(newPath: string): Promise<void> {
    if (!fs.existsSync(newPath)) {
      throw new Error(`Directory does not exist: ${newPath}`);
    }

    const stats = fs.statSync(newPath);
    if (!stats.isDirectory()) {
      throw new Error(`Path is not a directory: ${newPath}`);
    }

    console.log(`Changing video directory from ${this.videoDir} to ${newPath}`);
    this.videoDir = newPath;
    
    console.log(`Video directory changed to: ${this.videoDir}`);
    
    this.videos.clear();
    await this.loadVideos();
  }

  // „Éï„Ç©„É´„ÉÄÂÖ®‰Ωì„ÅÆ„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÔºàÈ´òÈÄüÂåñÁâàÔºâ
  async generateThumbnailsForCurrentFolder(options?: {
    skipExisting?: boolean;
    maxConcurrency?: number;
  }): Promise<{ successful: number; failed: number }> {
    const result = await this.thumbnailGenerator.generateThumbnailsForFolder(this.videoDir, {
      skipExisting: options?.skipExisting ?? true,
      maxConcurrency: options?.maxConcurrency ?? undefined,
      optimizeSettings: true
    });

    // „Çµ„É†„Éç„Ç§„É´„Éë„Çπ„ÇíÊõ¥Êñ∞
    result.successful.forEach(thumbnailPath => {
      const filename = path.basename(thumbnailPath);
      const videoId = filename.replace('_thumbnail.png', '');
      const video = this.videos.get(videoId);
      if (video) {
        video.thumbnailPath = thumbnailPath;
      }
    });

    return { 
      successful: result.successful.length, 
      failed: result.failed.length 
    };
  }

  // „Çµ„É†„Éç„Ç§„É´ÁîüÊàê„ÅÆÁµ±Ë®àÊÉÖÂ†±ÂèñÂæó
  getThumbnailStats(): {
    maxConcurrency: number;
    activeJobs: number;
    thumbnailDir: string;
    gpuCapabilities: any;
  } {
    return this.thumbnailGenerator.getStats();
  }

  // Ë∂ÖÈ´òÈÄü„Çµ„É†„Éç„Ç§„É´ÁîüÊàê
  async generateThumbnailsUltraFast(): Promise<{ successful: number; failed: number }> {
    const videos = Array.from(this.videos.values()).map(video => ({
      videoPath: video.path,
      videoId: video.id
    }));

    const result = await this.thumbnailGenerator.generateThumbnailsUltraFast(videos);

    // „Çµ„É†„Éç„Ç§„É´„Éë„Çπ„ÇíÊõ¥Êñ∞
    result.successful.forEach(thumbnailPath => {
      const filename = path.basename(thumbnailPath);
      const videoId = filename.replace('_thumbnail.png', '');
      const video = this.videos.get(videoId);
      if (video) {
        video.thumbnailPath = thumbnailPath;
      }
    });

    return { 
      successful: result.successful.length, 
      failed: result.failed.length 
    };
  }

  // „Éó„É≠„Ç∞„É¨„ÉÉ„Ç∑„Éñ„Çµ„É†„Éç„Ç§„É´ÁîüÊàê
  async generateThumbnailsProgressive(): Promise<{ successful: number; failed: number }> {
    const videos = Array.from(this.videos.values()).map(video => ({
      videoPath: video.path,
      videoId: video.id
    }));

    const result = await this.thumbnailGenerator.generateProgressiveThumbnails(videos);

    // „Çµ„É†„Éç„Ç§„É´„Éë„Çπ„ÇíÊõ¥Êñ∞
    result.successful.forEach(thumbnailPath => {
      const filename = path.basename(thumbnailPath);
      const videoId = filename.replace('_thumbnail.png', '');
      const video = this.videos.get(videoId);
      if (video) {
        video.thumbnailPath = thumbnailPath;
      }
    });

    return { 
      successful: result.successful.length, 
      failed: result.failed.length 
    };
  }

  // ===== ÁôªÈå≤„Éï„Ç©„É´„ÉÄÁÆ°ÁêÜÊ©üËÉΩ =====
  
  private readRegisteredFolders(): RegisteredFolder[] {
    try {
      if (!fs.existsSync(this.registeredFoldersFile)) {
        return [];
      }
      const content = fs.readFileSync(this.registeredFoldersFile, 'utf8');
      return JSON.parse(content) as RegisteredFolder[];
    } catch (error) {
      console.error('Failed to read registered folders:', error);
      return [];
    }
  }

  private writeRegisteredFolders(folders: RegisteredFolder[]): void {
    try {
      const dir = path.dirname(this.registeredFoldersFile);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(this.registeredFoldersFile, JSON.stringify(folders, null, 2), 'utf8');
    } catch (error) {
      console.error('Failed to write registered folders:', error);
    }
  }

  private generateFolderId(folderPath: string): string {
    return crypto.createHash('md5').update(path.resolve(folderPath)).digest('hex');
  }

  async getRegisteredFolders(): Promise<RegisteredFolder[]> {
    return this.readRegisteredFolders();
  }

  async addRegisteredFolder(folderPath: string, name?: string): Promise<RegisteredFolder> {
    if (!folderPath) {
      throw new Error('Folder path is required');
    }

    const resolvedPath = path.resolve(folderPath);
    
    // „Éï„Ç©„É´„ÉÄ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    if (!fs.existsSync(resolvedPath)) {
      throw new Error(`Folder does not exist: ${resolvedPath}`);
    }

    const stats = fs.statSync(resolvedPath);
    if (!stats.isDirectory()) {
      throw new Error(`Path is not a directory: ${resolvedPath}`);
    }

    const folders = this.readRegisteredFolders();
    const id = this.generateFolderId(resolvedPath);
    const displayName = name || path.basename(resolvedPath);

    // Êó¢Â≠ò„ÉÅ„Çß„ÉÉ„ÇØÔºàÂêå„Åò„Éë„Çπ„Åå„ÅÇ„Çå„Å∞Êõ¥Êñ∞Ôºâ
    const existingIndex = folders.findIndex(f => f.id === id);
    const newFolder: RegisteredFolder = {
      id,
      path: resolvedPath,
      name: displayName,
      createdAt: new Date()
    };

    if (existingIndex >= 0) {
      folders[existingIndex] = { ...folders[existingIndex], name: displayName };
    } else {
      folders.push(newFolder);
    }

    this.writeRegisteredFolders(folders);
    return newFolder;
  }

  async removeRegisteredFolder(id: string): Promise<void> {
    if (!id) {
      throw new Error('Folder ID is required');
    }

    const folders = this.readRegisteredFolders();
    const filteredFolders = folders.filter(f => f.id !== id);
    
    if (folders.length === filteredFolders.length) {
      throw new Error('Folder not found');
    }

    this.writeRegisteredFolders(filteredFolders);
  }

  async setRegisteredFolder(id: string): Promise<RegisteredFolder> {
    if (!id) {
      throw new Error('Folder ID is required');
    }

    const folders = this.readRegisteredFolders();
    const folder = folders.find(f => f.id === id);
    
    if (!folder) {
      throw new Error('Registered folder not found');
    }

    // „Éï„Ç©„É´„ÉÄ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    if (!fs.existsSync(folder.path)) {
      throw new Error(`Registered folder no longer exists: ${folder.path}`);
    }

    await this.changeVideoDirectory(folder.path);
    return folder;
  }

  // TS„Éï„Ç°„Ç§„É´„ÅÆ„Éà„É©„É≥„Çπ„Ç≥„Éº„ÉâÈñãÂßã
  async startTranscode(videoId: string): Promise<{ jobId: string }> {
    const video = this.videos.get(videoId);
    if (!video || !video.isTs) {
      throw new Error('TS video not found');
    }

    if (video.isTranscoding) {
      throw new Error('Video is already being transcoded');
    }

    console.log(`üîÑ Starting transcode for: ${video.originalName}`);

    // „Éà„É©„É≥„Çπ„Ç≥„Éº„ÉâÁä∂ÊÖã„ÇíÊõ¥Êñ∞
    video.isTranscoding = true;
    video.transcodeProgress = 0;

    const jobId = crypto.createHash('md5').update(`${videoId}-${Date.now()}`).digest('hex');

    // Á∞°ÊòìÁâàÔºö„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„Éà„É©„É≥„Çπ„Ç≥„Éº„Éâ„ÇíÈñãÂßã
    this.performTranscode(videoId, jobId).catch(error => {
      console.error(`Transcode failed for ${videoId}:`, error);
      // „Ç®„É©„ÉºÊôÇ„ÅØÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
      if (this.videos.has(videoId)) {
        const failedVideo = this.videos.get(videoId)!;
        failedVideo.isTranscoding = false;
        failedVideo.transcodeProgress = 0;
      }
    });

    return { jobId };
  }

  // „Éà„É©„É≥„Çπ„Ç≥„Éº„ÉâÈÄ≤ÊçóÁä∂Ê≥Å„ÅÆÂèñÂæó
  async getTranscodeProgress(jobId: string): Promise<{ progress: number; status: string }> {
    // Á∞°ÊòìÁâàÔºöÂÖ®„Å¶„ÅÆ„Éì„Éá„Ç™„Åã„ÇâÈÄ≤Ë°å‰∏≠„ÅÆ„ÇÇ„ÅÆ„ÇíÊ§úÁ¥¢
    for (const video of this.videos.values()) {
      if (video.isTranscoding) {
        return {
          progress: video.transcodeProgress || 0,
          status: 'transcoding'
        };
      }
    }

    return {
      progress: 100,
      status: 'completed'
    };
  }

  // ÂÆüÈöõ„ÅÆ„Éà„É©„É≥„Çπ„Ç≥„Éº„ÉâÂá¶ÁêÜÔºà„Éó„É©„Ç§„Éô„Éº„Éà„É°„ÇΩ„ÉÉ„ÉâÔºâ
  private async performTranscode(videoId: string, jobId: string): Promise<void> {
    const video = this.videos.get(videoId);
    if (!video || !video.isTs) {
      throw new Error('Video not found');
    }

    const inputPath = video.path;
    const outputPath = path.join(path.dirname(inputPath), path.basename(inputPath, '.ts') + '.mp4');

    console.log(`üìπ Transcoding ${inputPath} -> ${outputPath}`);

    try {
      // WSLÁí∞Â¢ÉÂØæÂøú„ÅÆFFmpegË®≠ÂÆöÔºàCPUÂ∞ÇÁî®„ÄÅÂõ∫ÂÆöÂìÅË≥™Ôºâ
      const ffmpeg = require('fluent-ffmpeg');
      const ffmpegPath = require('ffmpeg-static');
      
      if (ffmpegPath) {
        ffmpeg.setFfmpegPath(ffmpegPath);
      }

      await new Promise<void>((resolve, reject) => {
        ffmpeg(inputPath)
          .outputOptions([
            '-c:v', 'libx264',      // H.264 video codec
            '-preset', 'fast',      // „Ç®„É≥„Ç≥„Éº„ÉâÈÄüÂ∫¶ÂÑ™ÂÖà
            '-crf', '23',           // Âõ∫ÂÆöÂìÅË≥™
            '-c:a', 'aac',          // AAC audio codec
            '-b:a', '128k',         // Èü≥Â£∞„Éì„ÉÉ„Éà„É¨„Éº„Éà
            '-movflags', '+faststart', // WebÊúÄÈÅ©Âåñ
            '-y'                    // ‰∏äÊõ∏„ÅçË®±ÂèØ
          ])
          .on('start', (commandLine: string) => {
            console.log(`üöÄ FFmpeg command: ${commandLine}`);
          })
          .on('progress', (progress: any) => {
            const percent = Math.round(progress.percent || 0);
            console.log(`üìä Transcode progress: ${percent}%`);
            
            // ÈÄ≤Êçó„ÇíÊõ¥Êñ∞
            if (this.videos.has(videoId)) {
              this.videos.get(videoId)!.transcodeProgress = percent;
            }
          })
          .on('end', () => {
            console.log('‚úÖ Transcode completed successfully');
            resolve();
          })
          .on('error', (error: any) => {
            console.error('‚ùå Transcode error:', error);
            reject(error);
          })
          .save(outputPath);
      });

      // „Éà„É©„É≥„Çπ„Ç≥„Éº„ÉâÂÆå‰∫ÜÂæå„ÅÆÂá¶ÁêÜ
      const video = this.videos.get(videoId)!;
      video.isTranscoding = false;
      video.transcodeProgress = 100;

      console.log(`‚úÖ Transcode completed: ${outputPath}`);

      // „Éì„Éá„Ç™„É™„Çπ„Éà„ÇíÂÜçË™≠„ÅøËæº„ÅøÔºàÊñ∞„Åó„ÅÑMP4„Éï„Ç°„Ç§„É´„ÇíË™çË≠ò„Åï„Åõ„ÇãÔºâ
      setTimeout(() => {
        this.loadVideos();
      }, 1000);

    } catch (error) {
      console.error(`‚ùå Transcode failed for ${videoId}:`, error);
      
      // „Ç®„É©„ÉºÊôÇ„ÅÆÁä∂ÊÖã„É™„Çª„ÉÉ„Éà
      const video = this.videos.get(videoId);
      if (video) {
        video.isTranscoding = false;
        video.transcodeProgress = 0;
      }

      throw error;
    }
  }
}
